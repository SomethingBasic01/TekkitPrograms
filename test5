local storageDB = {}
local itemDB = {}
local itemLocations = {}  -- New table to track where items are stored
local userNamesMap = {}
local itemsPerPage = 10  -- Number of items to display per page

local chestNames = {}
local dispenserName

-- File to store the user-defined names
local nameMapFile = "userNamesMap.lua"

-- Load existing user-defined names from file
local function loadNameMap()
    if fs.exists(nameMapFile) then
        local handle = fs.open(nameMapFile, "r")
        local data = handle.readAll()
        handle.close()
        local func = loadstring("return " .. data)
        if func then
            userNamesMap = func()
            print("User-defined names loaded successfully.")
        else
            print("Error loading user-defined names.")
        end
    else
        print("No existing user-defined names found. Starting fresh.")
    end
end

-- Save current user-defined names to file
local function saveNameMap()
    local handle = fs.open(nameMapFile, "w")
    handle.write(textutils.serialize(userNamesMap))
    handle.close()
    print("User-defined names saved successfully.")
end

-- Function to create a unique key based on name, damage, and NBT
local function createUniqueKey(item)
    local baseKey = item.name .. ":" .. (item.damage or 0)
    if item.nbt then
        baseKey = baseKey .. ":" .. textutils.serialize(item.nbt)
    end
    return baseKey
end

-- Function to get or assign a user-defined name for an item
local function getOrAssignUserName(item)
    local uniqueKey = createUniqueKey(item)
    if not userNamesMap[uniqueKey] then
        print("New item detected: " .. item.name)
        print("Please enter a name for this item:")
        local userName = read()
        userNamesMap[uniqueKey] = userName
        saveNameMap()
    end
    return userNamesMap[uniqueKey]
end

-- Normalize a string (remove leading/trailing spaces and convert to lowercase)
local function normalizeString(str)
    return string.lower(str:gsub("^%s*(.-)%s*$", "%1"))
end

-- Scan and wrap all connected inventories and the dispenser
local function scanInventories()
    storageDB = {}
    itemDB = {}
    itemLocations = {}
    chestNames = {}
    dispenserName = nil

    local peripherals = peripheral.getNames()
    for _, name in ipairs(peripherals) do
        local p = peripheral.wrap(name)
        if p and p.list then
            if name:find("dispenser") then
                dispenserName = name
            else
                table.insert(chestNames, name)
                storageDB[name] = p

                -- Scan each chest and update itemDB and itemLocations
                local items = p.list()
                for slot, item in pairs(items) do
                    local userName = getOrAssignUserName(item)
                    local lowerName = normalizeString(userName)
                    local itemName = normalizeString(item.name)
                    
                    -- Track by both user-defined and original item names
                    if not itemDB[lowerName] then
                        itemDB[lowerName] = item.count
                        itemLocations[lowerName] = {}
                    else
                        itemDB[lowerName] = itemDB[lowerName] + item.count
                    end
                    if not itemDB[itemName] then
                        itemDB[itemName] = item.count
                        itemLocations[itemName] = {}
                    else
                        itemDB[itemName] = itemDB[itemName] + item.count
                    end

                    table.insert(itemLocations[lowerName], {chest = name, slot = slot})
                    table.insert(itemLocations[itemName], {chest = name, slot = slot})
                end
            end
        end
    end

    if dispenserName then
        print("Dispenser found: " .. dispenserName)
    else
        print("Dispenser not found.")
    end

    print("Inventories scanned: " .. tostring(#chestNames))
end

-- Function for the turtle to scan items and add them to the database
local function scanAndMapItems()
    term.clear()
    term.setCursorPos(1, 1)
    print("=== Label Items & Drop into Dispenser ===")
    for slot = 1, 16 do
        local item = turtle.getItemDetail(slot)
        if item then
            local userName = getOrAssignUserName(item)
            print("Scanned: " .. userName)
        else
            print("Slot " .. slot .. " is empty.")
        end
    end
end

-- Function to drop items into the dispenser below the turtle
local function dropItemsIntoDispenser()
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            turtle.select(slot)
            turtle.dropDown()
        end
    end
end

-- Update the item database by aggregating items from all inventories
local function updateDatabase()
    itemDB = {}  -- Clear the database before updating
    itemLocations = {} -- Clear the item locations before updating
    for _, chestName in ipairs(chestNames) do
        local chest = storageDB[chestName]
        local items = chest.list()
        for slot, item in pairs(items) do
            local userName = getOrAssignUserName(item)
            local lowerName = normalizeString(userName)
            local itemName = normalizeString(item.name)

            -- Track by both user-defined and original item names
            if not itemDB[lowerName] then
                itemDB[lowerName] = item.count
                itemLocations[lowerName] = {}
            else
                itemDB[lowerName] = itemDB[lowerName] + item.count
            end
            if not itemDB[itemName] then
                itemDB[itemName] = item.count
                itemLocations[itemName] = {}
            else
                itemDB[itemName] = itemDB[itemName] + item.count
            end

            table.insert(itemLocations[lowerName], {chest = chestName, slot = slot})
            table.insert(itemLocations[itemName], {chest = chestName, slot = slot})
        end
    end

    -- Debugging line to print the item database
    print("Item Database: " .. textutils.serialize(itemDB))
    print("Item Locations: " .. textutils.serialize(itemLocations))
end

-- Display the aggregated items neatly on the terminal with pagination
local function displayItems()
    -- Convert itemDB to a list format for easier pagination
    local itemList = {}
    for name, count in pairs(itemDB) do
        table.insert(itemList, {name = name, count = count})
    end

    -- Sort the list alphabetically
    table.sort(itemList, function(a, b) return a.name < b.name end)

    local totalItems = #itemList
    if totalItems == 0 then
        print("No items in storage.")
        sleep(2)
        return
    end

    local currentPage = 1
    local totalPages = math.ceil(totalItems / itemsPerPage)

    while true do
        term.clear()
        term.setCursorPos(1, 1)
        print("=== Combined Items in Storage ===")

        local startIndex = (currentPage - 1) * itemsPerPage + 1
        local endIndex = math.min(startIndex + itemsPerPage - 1, totalItems)

        for i = startIndex, endIndex do
            local item = itemList[i]
            if item then
                print(string.format("%-30s : %d", item.name, item.count))
            end
        end

        print(string.format("\nPage %d/%d", currentPage, totalPages))
        print("Press [N] for Next page, [P] for Previous page, [Q] to quit.")

        local event, key = os.pullEvent("key")
        if key == keys.n and currentPage < totalPages then
            currentPage = currentPage + 1
        elseif key == keys.p and currentPage > 1 then
            currentPage = currentPage - 1
        elseif key == keys.q then
            break
        end
    end
end

-- Function to display items with filter options
local function displayItemsWithFilter()
    -- Convert itemDB to a list format for easier pagination
    local itemList = {}
    for name, count in pairs(itemDB) do
        table.insert(itemList, {name = name, count = count})
    end

    -- Sort the list alphabetically
    table.sort(itemList, function(a, b) return a.name < b.name end)

    -- Prompt user for filter
    print("Enter filter (leave empty for no filter):")
    local filter = read()

    local filteredItemList = {}
    for _, item in ipairs(itemList) do
        if item.name:find(filter) then
            table.insert(filteredItemList, item)
        end
    end

    local totalItems = #filteredItemList
    if totalItems == 0 then
        print("No items matching filter in storage.")
        sleep(2)
        return
    end

    local currentPage = 1
    local totalPages = math.ceil(totalItems / itemsPerPage)

    while true do
        term.clear()
        term.setCursorPos(1, 1)
        print("=== Combined Items in Storage (Filtered) ===")

        local startIndex = (currentPage - 1) * itemsPerPage + 1
        local endIndex = math.min(startIndex + itemsPerPage - 1, totalItems)

        for i = startIndex, endIndex do
            local item = filteredItemList[i]
            if item then
                print(string.format("%-30s : %d", item.name, item.count))
            end
        end

        print(string.format("\nPage %d/%d", currentPage, totalPages))
        print("Press [N] for Next page, [P] for Previous page, [Q] to quit.")

        local event, key = os.pullEvent("key")
        if key == keys.n and currentPage < totalPages then
            currentPage = currentPage + 1
        elseif key == keys.p and currentPage > 1 then
            currentPage = currentPage - 1
        elseif key == keys.q then
            break
        end
    end
end

-- Function to withdraw items from storage into the turtle
local function withdrawItems()
    print("Enter the name of the item you want to withdraw:")
    local itemName = normalizeString(read())  -- Convert to normalized string for comparison

    print("Enter the quantity you want to withdraw:")
    local quantity = tonumber(read())

    if not quantity or quantity <= 0 then
        print("Invalid quantity entered.")
        return
    end

    local remainingQuantity = quantity
    if itemLocations[itemName] then
        for _, location in ipairs(itemLocations[itemName]) do
            local chestName = location.chest
            local slot = location.slot
            local chest = storageDB[chestName]

            if chest then
                local countToWithdraw = math.min(remainingQuantity, chest.getItemDetail(slot).count)

                -- Attempt to push items from chest to turtle
                local success = chest.pushItems(peripheral.getName(turtle), slot, countToWithdraw)

                if success > 0 then
                    remainingQuantity = remainingQuantity - success
                    print("Withdrew " .. success .. " of " .. itemName .. " from " .. chestName)
                end
                
                -- If the full quantity is withdrawn, exit early
                if remainingQuantity <= 0 then
                    print("Successfully withdrew " .. quantity .. " of " .. itemName)
                    return
                end
            else
                print("Failed to wrap the chest: " .. chestName)
            end
        end
    else
        print("Item not found in storage.")
    end

    if remainingQuantity > 0 then
        print("Could only withdraw " .. (quantity - remainingQuantity) .. " of " .. itemName .. ". Not enough items in storage.")
    end
end

-- Function to run your provided test code when option 3 is selected
local function runTestCode()
    local chestNames = {}
    local dispenserName

    -- Scan and find peripherals dynamically, including all chest types
    local function findPeripherals()
        local peripherals = peripheral.getNames()
        for _, name in ipairs(peripherals) do
            local p = peripheral.wrap(name)
            if p and p.list and name ~= "bottom" then  -- Check for any inventory-like peripheral
                if name:find("dispenser") then
                    dispenserName = name
                else
                    table.insert(chestNames, name)
                end
            end
        end
    end

    -- Function to try and push items into a chest
    local function tryPushToChest(dispenser, slot, count)
        for _, chestName in ipairs(chestNames) do
            local chest = peripheral.wrap(chestName)
            if chest then
                local moved = dispenser.pushItems(peripheral.getName(chest), slot, count)
                if moved > 0 then
                    print("Moved " .. moved .. " items from dispenser to " .. chestName)
                    return true
                end
            end
        end
        return false
    end

    -- Function to transfer items from dispenser to chest
    local function transferItems()
        if dispenserName then
            local dispenser = peripheral.wrap(dispenserName)
            
            if dispenser then
                -- Iterate through the dispenser slots
                for slot, item in pairs(dispenser.list()) do
                    local success = tryPushToChest(dispenser, slot, item.count)
                    if not success then
                        print("Failed to move item from dispenser to any chest. All chests might be full.")
                    end
                end
            else
                print("Failed to wrap the dispenser.")
            end
        else
            print("Dispenser not found.")
        end
    end

    -- Main function to run the program
    local function main()
        findPeripherals()

        -- Check if the peripherals are found
        if #chestNames > 0 and dispenserName then
            print("Chests found: " .. table.concat(chestNames, ", "))
            print("Dispenser found: " .. dispenserName)
            transferItems()
        else
            print("Failed to detect necessary peripherals. Cannot proceed.")
        end
    end

    -- Run the main function
    main()
end

-- Main menu to navigate between different modes
local function mainMenu()
    while true do
        term.clear()
        term.setCursorPos(1, 1)
        print("=== Modular Storage System ===")
        print("1. View Items in Storage")
        print("2. Label Items & Drop into Dispenser")
        print("3. Transfer Items from Dispenser to Chests")
        print("4. Withdraw Items from Storage")
        print("5. Exit Program")
        print("\nSelect an option by typing the number and pressing Enter:")

        local choice = read()

        if choice == "1" then
            updateDatabase()
            displayItemsWithFilter()
        elseif choice == "2" then
            scanAndMapItems()
            dropItemsIntoDispenser()
        elseif choice == "3" then
            runTestCode()  -- This runs your provided test code
            sleep(2)  -- Optional pause before returning to menu
        elseif choice == "4" then
            withdrawItems()
            sleep(2)
        elseif choice == "5" then
            term.clear()
            term.setCursorPos(1, 1)
            print("Exiting program. Goodbye!")
            break
        else
            print("Invalid choice. Please select a valid option.")
            sleep(2)
        end
    end
end

-- Main program
local function main()
    loadNameMap()
    scanInventories()
    mainMenu()
end

-- Run the program
main()
